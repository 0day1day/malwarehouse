#!/usr/bin/env python
# encoding: utf-8
"""
malwarehouse.py

Created by Scott Roberts.
Copyright (c) 2012 TogaFoamParty Studios. All rights reserved.
"""

import datetime
import os
import hashlib
import sqlite3
import shutil
import re
from optparse import OptionParser

option_base_dir = os.path.expanduser("~/Desktop/malwarehouse/")

def check_prelim():
  """Initial setup code. Eventually this will set options."""

  db_path = option_base_dir + "malwarehouse.db"
  dir_path = os.path.dirname(option_base_dir)
  
  if not os.path.exists(dir_path):
    print "[ERROR] Base directory %s doesn't exist. Creating it..." % (dir_path)
    os.makedirs(dir_path)

  if not os.path.exists(db_path):
    print "[ERROR] Database %s doesn't exist. Creating it..." % (db_path)
    
    conn = sqlite3.connect(db_path)
    c = conn.cursor()

    # Create table
    c.execute('''CREATE TABLE IF NOT EXISTS malwarehouse_index (datetime text, name text, tags text, size integer, md5 text, sha256 text, source text, notes text)''')

    # Save (commit) the changes
    conn.commit()
  
    # We can also close the cursor if we are done with it
    c.close()

  return True

def get_md5(malware_path):
  """Wrapper for the usual md5 call because it's so verbose."""
  
  return hashlib.md5(file(malware_path, 'r').read()).hexdigest()

def get_sha256(malware_path):
  """Wrapper for the usual sha256 call because it's so verbose."""
  
  return hashlib.sha256(file(malware_path, 'r').read()).hexdigest()

# Built In Tagging Methods
def auto_tagger(malware_path):
  """Runs tagging modules automatically and returns a string of comma seperated tags."""
  auto_tags = []

  # Auto Tag Modules
  auto_tags.append(get_mimetype(malware_path))

  return ", ".join(auto_tags)

def get_mimetype(malware_path):
    """Finds the standard mimetype for file and returns type name."""
    try:
        import magic 
        mime = magic.Magic(mime=True)
        return mime.from_file(malware_path)
        raise
    except: 
        return False

def summary(report_json):
  """Prints an easy to read summary of the malware."""
  
  return "- %s (%s) - %s" % (report_json['name'], report_json['source'], report_json['md5'])

def details(report_json):
  """Prints an easy to read summary of the malware."""
  
  details = ""
  details += "datetime: %s\n" % (report_json['datetime'])
  details += "name:     %s\n" % (report_json['name'])
  details += "tags:     %s\n" % (report_json['tags'])
  details += "size:     %s\n" % (report_json['size'])
  details += "md5:      %s\n" % (report_json['md5'])
  details += "sha256:   %s\n" % (report_json['sha256'])
  details += "source:   %s\n" % (report_json['source'])
  details += "notes:    %s\n" % (report_json["notes"])
  details += "\n"
  details += "sample directory: %s" % option_base_dir + report_json['sha256']

  return details

def load_db(report_json):
  """Load information about the sample into the index DB."""

  conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
  c = conn.cursor()

  # Insert a row of data 
  c.execute("INSERT INTO malwarehouse_index VALUES (\'%s\', \'%s\', \'%s\', \'%d\', \'%s\', \'%s\', \'%s\', \'%s\')" % (report_json['datetime'], report_json['name'], report_json['tags'], report_json['size'], report_json['md5'], report_json['sha256'], report_json['source'], report_json['notes'])) 
  
  # Save (commit) the changes
  conn.commit()
  
  # We can also close the cursor if we are done with it
  c.close()

  print "Sample %s loaded..." % report_json['name']
  return True

def load_directory(report_json, malware_path):
  """Creates a directory to store the malware and summary."""
  print "Loading Malware %s" % malware_path

  sample_dir = "%s%s" % (option_base_dir, report_json['sha256'])

  if not os.path.exists(sample_dir):
    print "Creating %s" % (sample_dir)
    os.makedirs(sample_dir)

  shutil.move(malware_path, sample_dir)

  with open(sample_dir + '/summary.txt', 'w') as text_file:
    text_file.write(details(report_json))

  return True

def find_sample(find_string):
    
    conn = sqlite3.connect(option_base_dir + "malwarehouse.db")
    c = conn.cursor()
    
    if re.findall(r"^([a-fA-F\d]{32})$", find_string):
        #print "\nResults for md5: %s" % find_string
        c.execute("SELECT * FROM malwarehouse_index WHERE md5 = ?", (find_string,))
    elif re.findall(r"^([a-fA-F\d]{64})$", find_string):
        #print "\nResults for sha256: %s" % find_string
        c.execute("SELECT * FROM malwarehouse_index WHERE sha256 = ?", (find_string,))
    else:
        #print "\nResults for file name: %s" % find_string
        c.execute("SELECT * FROM malwarehouse_index WHERE name = ?", (find_string,))

    data=c.fetchall()
    
    if data is None:
        print('There is no component named %s'%find_string)
        return False
    else:
        print "\nResults:"
        for result in data:
            print summary({'datetime': result[0], 'name': result[1], 'tags':result[2], 'size': result[3], 'md5': result[4], 'sha256': result[5], 'source': result[6], 'notes': result[7]})
        return True
    

def main():
    if not check_prelim():
      print "[ERROR] Initial setup unable to complete. Exiting..."
      return False

    malware_definition = {
        "datetime": "", #calculated
        "name": "", #autodetected
        "tags": "",
        "size": "", #calculated
        "md5": "", #calculated
        "sha256": "", #calculated
        "source": "",
        "notes": "",
    }

    parser = OptionParser(usage="usage: %prog [options] filepath", version="%prog 0.1")
    parser.add_option("-s", "--source",
                      action="store",
                      type="string",
                      dest="SOURCE",
                      default=None,
                      help="Source of file")
    parser.add_option("-t", "--tags",
                      action="store",
                      type="string",
                      dest="TAGS",
                      default="No tags",
                      help="Any characteristics of the malware")
    parser.add_option("-n", "--notes",
                      action="store",
                      type="string",
                      dest="NOTES",
                      default="",
                      help="Notes about file")
    parser.add_option("-f", "--find",
                      action="store",
                      type="string",
                      dest="FIND",
                      default="",
                      help="Find a sample by name, md5, or sha256")
    parser.add_option("-a", "--autotag",
                      action="store",
                      type="string",
                      dest="AUTOTAG",
                      default="all",
                      help="Run auto tagging against malware")
    
    (options, args) = parser.parse_args()
    
    if options.FIND:
        if find_sample(options.FIND):
            return True
        else:
            return False
    elif options.AUTOTAG:
        if options.AUTOTAG == "all":
          print "Autotagging everything mother futon!"
          return True
        else:
          print "Autotagging %s" % (options.AUTOTAG)
          return True
    elif len(args) != 1:
        parser.error("You didn't specify a malware target path.")
        return False
    else:
        #Parse malware file path and name
        malware_path = args[0]
        malware_filename = malware_path.split('/')[-1]

    #Parsing Custom Options    
    if options.SOURCE: malware_definition["source"] = options.SOURCE
    if options.TAGS: malware_definition["tags"] = options.TAGS
    if options.NOTES: malware_definition["notes"] = options.NOTES

    #Parsing Automatically Generated Options
    print "Parsing Malware"
    malware_definition["name"] = malware_filename
    malware_definition["datetime"] = str(datetime.datetime.now())
    malware_definition["size"] = os.stat(malware_path).st_size
    malware_definition["md5"] = get_md5(malware_path)
    malware_definition["sha256"] = get_sha256(malware_path) 

    print "Analysis complete. Loading."
    load_directory(malware_definition, malware_path)
    load_db(malware_definition)
    
    return True

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print "User aborted."
    except SystemExit:
        pass
    #except:
        #SystemExit

